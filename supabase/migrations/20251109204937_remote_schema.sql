create extension if not exists "pgjwt" with schema "extensions";

create sequence "public"."blog_posts_id_seq";


  create table "public"."blog_posts" (
    "id" bigint not null default nextval('public.blog_posts_id_seq'::regclass),
    "title" text not null,
    "slug" text not null,
    "summary" text not null,
    "featured_image" text,
    "author" text not null,
    "published_at" timestamp with time zone not null default now(),
    "category" text not null,
    "tags" text[] default '{}'::text[],
    "status" text not null default 'draft'::text,
    "reading_time" integer not null default 5,
    "locale" text not null default 'en'::text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "call_to_action_metadata" jsonb,
    "content_metadata" jsonb[],
    "page_metadata" jsonb
      );


alter table "public"."blog_posts" enable row level security;


  create table "public"."chats" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "chat_provider_id" text,
    "provider_name" text,
    "title" text
      );


alter table "public"."chats" enable row level security;


  create table "public"."companies" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "image_url" text
      );


alter table "public"."companies" enable row level security;


  create table "public"."favorites" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "item_type" character varying(20) not null,
    "item_id" uuid not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "favorite_type" text
      );


alter table "public"."favorites" enable row level security;


  create table "public"."landing_page_blog_posts" (
    "id" uuid not null default gen_random_uuid(),
    "title" jsonb not null,
    "slug" text not null,
    "excerpt" jsonb,
    "content" jsonb not null,
    "author_id" uuid,
    "published" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "image_url" text
      );


alter table "public"."landing_page_blog_posts" enable row level security;


  create table "public"."landing_page_contact_form" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "email" text,
    "subject" text,
    "message" text,
    "company" text
      );


alter table "public"."landing_page_contact_form" enable row level security;


  create table "public"."messages" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "chat_provider_id" text,
    "message_provider_id" text,
    "role" text,
    "model" text,
    "parent_message_provider_id" text,
    "tools" text[],
    "content" text
      );


alter table "public"."messages" enable row level security;


  create table "public"."notifications" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "read_at" timestamp with time zone,
    "type" text,
    "title" text,
    "body" text,
    "metadata" jsonb
      );


alter table "public"."notifications" enable row level security;


  create table "public"."organizations" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "banner_url" text,
    "image_url" text,
    "website_url" text,
    "description" jsonb
      );


alter table "public"."organizations" enable row level security;


  create table "public"."prompt_blocks" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "company_id" uuid,
    "organization_id" uuid,
    "user_id" uuid,
    "type" text,
    "content" jsonb,
    "title" jsonb,
    "description" jsonb,
    "published" boolean not null default false,
    "status" text,
    "team_ids" uuid[],
    "workspace_type" text not null default ''::text,
    "usage_count" bigint default '0'::bigint,
    "updated_at" timestamp with time zone
      );


alter table "public"."prompt_blocks" enable row level security;


  create table "public"."prompt_folders" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "organization_id" uuid,
    "parent_folder_id" uuid,
    "title" jsonb,
    "description" jsonb,
    "company_id" uuid,
    "workspace_type" text not null,
    "id" uuid not null default extensions.uuid_generate_v4()
      );


alter table "public"."prompt_folders" enable row level security;


  create table "public"."prompt_templates" (
    "created_at" timestamp with time zone not null default now(),
    "tags" text[],
    "last_used_at" timestamp with time zone,
    "path" text,
    "workspace_type" text not null,
    "usage_count" bigint default '0'::bigint,
    "user_id" uuid,
    "company_id" uuid,
    "description" jsonb,
    "organization_id" uuid,
    "title" jsonb,
    "team_ids" uuid[],
    "is_free" boolean default true,
    "updated_at" timestamp with time zone not null default now(),
    "id" uuid not null default extensions.uuid_generate_v4(),
    "folder_id" uuid,
    "author_id" uuid,
    "current_version_id" bigint
      );


alter table "public"."prompt_templates" enable row level security;


  create table "public"."prompt_templates_comments" (
    "id" uuid not null default gen_random_uuid(),
    "template_id" uuid not null,
    "version_id" bigint,
    "user_id" uuid not null,
    "content" jsonb not null default '{"en": ""}'::jsonb,
    "parent_comment_id" uuid,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "is_resolved" boolean not null default false,
    "mentions" jsonb
      );


alter table "public"."prompt_templates_comments" enable row level security;


  create table "public"."prompt_templates_versions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "version_number" text not null,
    "content" jsonb not null default '{"en": "", "fr": ""}'::jsonb,
    "author_id" uuid not null,
    "usage_count" bigint not null default 0,
    "parent_version_id" bigint,
    "change_notes" jsonb default '{"en": "", "fr": ""}'::jsonb,
    "status" text not null default 'draft'::text,
    "template_id" uuid,
    "is_current" boolean default false,
    "optimized_for" text[],
    "is_published" boolean default false
      );


alter table "public"."prompt_templates_versions" enable row level security;


  create table "public"."share_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "invited_user_id" uuid,
    "inviter_email" text not null,
    "inviter_name" text not null,
    "invited_email" text,
    "invitation_type" text not null,
    "status" text not null default 'pending'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "sent_at" timestamp with time zone,
    "metadata" jsonb default '{}'::jsonb,
    "locale" text,
    "organization_id" uuid,
    "inviter_user_id" uuid
      );


alter table "public"."share_invitations" enable row level security;


  create table "public"."stripe_subscriptions" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "stripe_customer_id" text not null,
    "stripe_subscription_id" text not null,
    "stripe_price_id" text not null,
    "stripe_product_id" text not null,
    "status" text not null,
    "current_period_start" timestamp with time zone,
    "current_period_end" timestamp with time zone,
    "cancel_at_period_end" boolean default false,
    "cancelled_at" timestamp with time zone,
    "trial_start" timestamp with time zone,
    "trial_end" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."stripe_subscriptions" enable row level security;


  create table "public"."stripe_webhook_events" (
    "id" uuid not null default gen_random_uuid(),
    "stripe_event_id" character varying(255) not null,
    "event_type" character varying(100) not null,
    "event_data" jsonb not null,
    "processed" boolean default false,
    "created_at" timestamp with time zone default now(),
    "processed_at" timestamp with time zone
      );


alter table "public"."stripe_webhook_events" enable row level security;


  create table "public"."subscription_audit_log" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "old_status" text,
    "new_status" text,
    "old_plan" text,
    "new_plan" text,
    "stripe_event_id" text,
    "changed_by" text,
    "changed_at" timestamp with time zone default now(),
    "metadata" jsonb
      );


alter table "public"."subscription_audit_log" enable row level security;


  create table "public"."teams" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "company_id" uuid,
    "name" jsonb,
    "description" jsonb,
    "parent_team_id" uuid,
    "team_admins" uuid[]
      );


alter table "public"."teams" enable row level security;


  create table "public"."users_metadata" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid,
    "name" text,
    "phone_number" text,
    "pinned_official_folder_ids" bigint[],
    "pinned_organization_folder_ids" bigint[],
    "preferences_metadata" jsonb,
    "additional_email" text,
    "additional_organization" text,
    "linkedin_headline" text,
    "linkedin_id" text,
    "linkedin_profile_url" text,
    "email" text,
    "google_id" text,
    "company_id" uuid,
    "interests" text[],
    "job_industry" text,
    "job_seniority" text,
    "job_type" text,
    "organization_ids" uuid[],
    "pinned_folder_ids" text[],
    "pinned_template_ids" text[],
    "signup_source" text,
    "pinned_block_ids" bigint[],
    "profile_picture_url" text,
    "roles" jsonb,
    "data_collection" boolean default false,
    "first_block_created" boolean default false,
    "first_template_created" boolean default false,
    "first_template_used" boolean default false,
    "keyboard_shortcut_used" boolean default false,
    "onboarding_dismissed" boolean default false,
    "stripe_customer_id" character varying(255),
    "stripe_subscription_id" character varying(255),
    "subscription_cancel_at_period_end" boolean default false,
    "subscription_current_period_end" timestamp with time zone,
    "subscription_plan" character varying(50),
    "subscription_status" character varying(50) default 'free'::character varying
      );


alter table "public"."users_metadata" enable row level security;

alter sequence "public"."blog_posts_id_seq" owned by "public"."blog_posts"."id";

CREATE UNIQUE INDEX blog_posts_pkey ON public.blog_posts USING btree (id);

CREATE UNIQUE INDEX blog_posts_slug_key ON public.blog_posts USING btree (slug);

CREATE UNIQUE INDEX chats_pkey ON public.chats USING btree (id);

CREATE UNIQUE INDEX companies_pkey ON public.companies USING btree (id);

CREATE UNIQUE INDEX favorites_pkey ON public.favorites USING btree (id);

CREATE UNIQUE INDEX favorites_user_id_item_type_item_id_key ON public.favorites USING btree (user_id, item_type, item_id);

CREATE INDEX idx_blog_posts_category ON public.blog_posts USING btree (category);

CREATE INDEX idx_blog_posts_locale ON public.blog_posts USING btree (locale);

CREATE INDEX idx_blog_posts_published_at ON public.blog_posts USING btree (published_at);

CREATE INDEX idx_blog_posts_slug ON public.blog_posts USING btree (slug);

CREATE INDEX idx_blog_posts_status ON public.blog_posts USING btree (status);

CREATE INDEX idx_favorites_created_at ON public.favorites USING btree (created_at DESC);

CREATE INDEX idx_favorites_item_type ON public.favorites USING btree (item_type);

CREATE INDEX idx_favorites_user_id ON public.favorites USING btree (user_id);

CREATE INDEX idx_favorites_user_item ON public.favorites USING btree (user_id, item_type);

CREATE INDEX idx_prompt_folders_parent_folder_id ON public.prompt_folders USING btree (parent_folder_id);

CREATE INDEX idx_prompt_template_comments_created_at ON public.prompt_templates_comments USING btree (created_at DESC);

CREATE INDEX idx_prompt_template_comments_parent_id ON public.prompt_templates_comments USING btree (parent_comment_id);

CREATE INDEX idx_prompt_template_comments_template_id ON public.prompt_templates_comments USING btree (template_id);

CREATE INDEX idx_prompt_template_comments_user_id ON public.prompt_templates_comments USING btree (user_id);

CREATE INDEX idx_prompt_template_comments_version_id ON public.prompt_templates_comments USING btree (version_id);

CREATE INDEX idx_prompt_templates_versions_author_id ON public.prompt_templates_versions USING btree (author_id);

CREATE INDEX idx_prompt_templates_versions_parent_version_id ON public.prompt_templates_versions USING btree (parent_version_id) WHERE (parent_version_id IS NOT NULL);

CREATE INDEX idx_prompt_templates_versions_template_id ON public.prompt_templates_versions USING btree (template_id);

CREATE INDEX idx_prompt_templates_versions_version_number ON public.prompt_templates_versions USING btree (version_number);

CREATE INDEX idx_share_invitations_org_status ON public.share_invitations USING btree (organization_id, status);

CREATE INDEX idx_share_invitations_org_type_status ON public.share_invitations USING btree (organization_id, invitation_type, status);

CREATE INDEX idx_share_invitations_organization_id ON public.share_invitations USING btree (organization_id);

CREATE INDEX idx_share_invitations_status ON public.share_invitations USING btree (status);

CREATE INDEX idx_share_invitations_type ON public.share_invitations USING btree (invitation_type);

CREATE INDEX idx_share_invitations_user_id ON public.share_invitations USING btree (invited_user_id);

CREATE INDEX idx_stripe_webhook_events_processed ON public.stripe_webhook_events USING btree (processed);

CREATE INDEX idx_stripe_webhook_events_stripe_id ON public.stripe_webhook_events USING btree (stripe_event_id);

CREATE INDEX idx_stripe_webhook_events_type ON public.stripe_webhook_events USING btree (event_type);

CREATE INDEX idx_users_metadata_linkedin_id ON public.users_metadata USING btree (linkedin_id);

CREATE INDEX idx_users_metadata_stripe_customer ON public.users_metadata USING btree (stripe_customer_id);

CREATE INDEX idx_users_metadata_stripe_subscription ON public.users_metadata USING btree (stripe_subscription_id);

CREATE INDEX idx_users_metadata_subscription_status ON public.users_metadata USING btree (subscription_status);

CREATE UNIQUE INDEX landing_page_contact_form_pkey ON public.landing_page_contact_form USING btree (id);

CREATE UNIQUE INDEX messages_pkey ON public.messages USING btree (id);

CREATE UNIQUE INDEX notifications_pkey ON public.notifications USING btree (id);

CREATE UNIQUE INDEX organizations_pkey ON public.organizations USING btree (id);

CREATE UNIQUE INDEX prompt_blocks_pkey ON public.prompt_blocks USING btree (id);

CREATE UNIQUE INDEX prompt_folders_pkey ON public.prompt_folders USING btree (id);

CREATE UNIQUE INDEX prompt_template_comments_pkey ON public.prompt_templates_comments USING btree (id);

CREATE UNIQUE INDEX prompt_templates_pkey ON public.prompt_templates USING btree (id);

CREATE UNIQUE INDEX prompt_templates_versions_pkey ON public.prompt_templates_versions USING btree (id);

CREATE UNIQUE INDEX share_invitations_pkey ON public.share_invitations USING btree (id);

CREATE UNIQUE INDEX stripe_subscriptions_pkey ON public.stripe_subscriptions USING btree (id);

CREATE UNIQUE INDEX stripe_subscriptions_stripe_subscription_id_key ON public.stripe_subscriptions USING btree (stripe_subscription_id);

CREATE UNIQUE INDEX stripe_webhook_events_pkey ON public.stripe_webhook_events USING btree (id);

CREATE UNIQUE INDEX stripe_webhook_events_stripe_event_id_key ON public.stripe_webhook_events USING btree (stripe_event_id);

CREATE UNIQUE INDEX subscription_audit_log_pkey ON public.subscription_audit_log USING btree (id);

CREATE UNIQUE INDEX teams_pkey ON public.teams USING btree (id);

CREATE UNIQUE INDEX users_metadata_pkey ON public.users_metadata USING btree (id);

alter table "public"."blog_posts" add constraint "blog_posts_pkey" PRIMARY KEY using index "blog_posts_pkey";

alter table "public"."chats" add constraint "chats_pkey" PRIMARY KEY using index "chats_pkey";

alter table "public"."companies" add constraint "companies_pkey" PRIMARY KEY using index "companies_pkey";

alter table "public"."favorites" add constraint "favorites_pkey" PRIMARY KEY using index "favorites_pkey";

alter table "public"."landing_page_contact_form" add constraint "landing_page_contact_form_pkey" PRIMARY KEY using index "landing_page_contact_form_pkey";

alter table "public"."messages" add constraint "messages_pkey" PRIMARY KEY using index "messages_pkey";

alter table "public"."notifications" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."organizations" add constraint "organizations_pkey" PRIMARY KEY using index "organizations_pkey";

alter table "public"."prompt_blocks" add constraint "prompt_blocks_pkey" PRIMARY KEY using index "prompt_blocks_pkey";

alter table "public"."prompt_folders" add constraint "prompt_folders_pkey" PRIMARY KEY using index "prompt_folders_pkey";

alter table "public"."prompt_templates" add constraint "prompt_templates_pkey" PRIMARY KEY using index "prompt_templates_pkey";

alter table "public"."prompt_templates_comments" add constraint "prompt_template_comments_pkey" PRIMARY KEY using index "prompt_template_comments_pkey";

alter table "public"."prompt_templates_versions" add constraint "prompt_templates_versions_pkey" PRIMARY KEY using index "prompt_templates_versions_pkey";

alter table "public"."share_invitations" add constraint "share_invitations_pkey" PRIMARY KEY using index "share_invitations_pkey";

alter table "public"."stripe_subscriptions" add constraint "stripe_subscriptions_pkey" PRIMARY KEY using index "stripe_subscriptions_pkey";

alter table "public"."stripe_webhook_events" add constraint "stripe_webhook_events_pkey" PRIMARY KEY using index "stripe_webhook_events_pkey";

alter table "public"."subscription_audit_log" add constraint "subscription_audit_log_pkey" PRIMARY KEY using index "subscription_audit_log_pkey";

alter table "public"."teams" add constraint "teams_pkey" PRIMARY KEY using index "teams_pkey";

alter table "public"."users_metadata" add constraint "users_metadata_pkey" PRIMARY KEY using index "users_metadata_pkey";

alter table "public"."blog_posts" add constraint "blog_posts_slug_key" UNIQUE using index "blog_posts_slug_key";

alter table "public"."chats" add constraint "chats_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."chats" validate constraint "chats_user_id_fkey";

alter table "public"."favorites" add constraint "favorites_item_type_check" CHECK (((item_type)::text = ANY (ARRAY[('template'::character varying)::text, ('folder'::character varying)::text]))) not valid;

alter table "public"."favorites" validate constraint "favorites_item_type_check";

alter table "public"."favorites" add constraint "favorites_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."favorites" validate constraint "favorites_user_id_fkey";

alter table "public"."favorites" add constraint "favorites_user_id_item_type_item_id_key" UNIQUE using index "favorites_user_id_item_type_item_id_key";

alter table "public"."messages" add constraint "messages_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."messages" validate constraint "messages_user_id_fkey";

alter table "public"."notifications" add constraint "notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."notifications" validate constraint "notifications_user_id_fkey";

alter table "public"."prompt_blocks" add constraint "prompt_blocks_workspace_type_check" CHECK ((workspace_type = ANY (ARRAY['user'::text, 'company'::text, 'organization'::text]))) not valid;

alter table "public"."prompt_blocks" validate constraint "prompt_blocks_workspace_type_check";

alter table "public"."prompt_folders" add constraint "prompt_folders_company_id_fkey" FOREIGN KEY (company_id) REFERENCES public.companies(id) not valid;

alter table "public"."prompt_folders" validate constraint "prompt_folders_company_id_fkey";

alter table "public"."prompt_folders" add constraint "prompt_folders_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) not valid;

alter table "public"."prompt_folders" validate constraint "prompt_folders_organization_id_fkey";

alter table "public"."prompt_folders" add constraint "prompt_folders_parent_folder_id_fkey" FOREIGN KEY (parent_folder_id) REFERENCES public.prompt_folders(id) ON DELETE CASCADE not valid;

alter table "public"."prompt_folders" validate constraint "prompt_folders_parent_folder_id_fkey";

alter table "public"."prompt_folders" add constraint "prompt_folders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."prompt_folders" validate constraint "prompt_folders_user_id_fkey";

alter table "public"."prompt_folders" add constraint "prompt_folders_workspace_type_check" CHECK ((workspace_type = ANY (ARRAY['user'::text, 'company'::text, 'organization'::text]))) not valid;

alter table "public"."prompt_folders" validate constraint "prompt_folders_workspace_type_check";

alter table "public"."prompt_templates" add constraint "prompt_templates_author_id_fkey" FOREIGN KEY (author_id) REFERENCES auth.users(id) not valid;

alter table "public"."prompt_templates" validate constraint "prompt_templates_author_id_fkey";

alter table "public"."prompt_templates" add constraint "prompt_templates_company_id_fkey" FOREIGN KEY (company_id) REFERENCES public.companies(id) not valid;

alter table "public"."prompt_templates" validate constraint "prompt_templates_company_id_fkey";

alter table "public"."prompt_templates" add constraint "prompt_templates_current_version_id_fkey" FOREIGN KEY (current_version_id) REFERENCES public.prompt_templates_versions(id) not valid;

alter table "public"."prompt_templates" validate constraint "prompt_templates_current_version_id_fkey";

alter table "public"."prompt_templates" add constraint "prompt_templates_folder_id_fkey" FOREIGN KEY (folder_id) REFERENCES public.prompt_folders(id) ON DELETE SET NULL not valid;

alter table "public"."prompt_templates" validate constraint "prompt_templates_folder_id_fkey";

alter table "public"."prompt_templates" add constraint "prompt_templates_organization_id_fkey" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) not valid;

alter table "public"."prompt_templates" validate constraint "prompt_templates_organization_id_fkey";

alter table "public"."prompt_templates" add constraint "prompt_templates_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."prompt_templates" validate constraint "prompt_templates_user_id_fkey";

alter table "public"."prompt_templates" add constraint "prompt_templates_workspace_type_check" CHECK ((workspace_type = ANY (ARRAY['user'::text, 'company'::text, 'organization'::text]))) not valid;

alter table "public"."prompt_templates" validate constraint "prompt_templates_workspace_type_check";

alter table "public"."prompt_templates_comments" add constraint "prompt_template_comments_parent_comment_id_fkey" FOREIGN KEY (parent_comment_id) REFERENCES public.prompt_templates_comments(id) ON DELETE CASCADE not valid;

alter table "public"."prompt_templates_comments" validate constraint "prompt_template_comments_parent_comment_id_fkey";

alter table "public"."prompt_templates_comments" add constraint "prompt_template_comments_template_id_fkey" FOREIGN KEY (template_id) REFERENCES public.prompt_templates(id) ON DELETE CASCADE not valid;

alter table "public"."prompt_templates_comments" validate constraint "prompt_template_comments_template_id_fkey";

alter table "public"."prompt_templates_comments" add constraint "prompt_template_comments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."prompt_templates_comments" validate constraint "prompt_template_comments_user_id_fkey";

alter table "public"."prompt_templates_comments" add constraint "prompt_template_comments_version_id_fkey" FOREIGN KEY (version_id) REFERENCES public.prompt_templates_versions(id) ON DELETE CASCADE not valid;

alter table "public"."prompt_templates_comments" validate constraint "prompt_template_comments_version_id_fkey";

alter table "public"."prompt_templates_versions" add constraint "prompt_templates_versions_author_id_fkey" FOREIGN KEY (author_id) REFERENCES auth.users(id) ON DELETE RESTRICT not valid;

alter table "public"."prompt_templates_versions" validate constraint "prompt_templates_versions_author_id_fkey";

alter table "public"."prompt_templates_versions" add constraint "prompt_templates_versions_parent_version_id_fkey" FOREIGN KEY (parent_version_id) REFERENCES public.prompt_templates_versions(id) ON DELETE SET NULL not valid;

alter table "public"."prompt_templates_versions" validate constraint "prompt_templates_versions_parent_version_id_fkey";

alter table "public"."prompt_templates_versions" add constraint "prompt_templates_versions_template_id_fkey" FOREIGN KEY (template_id) REFERENCES public.prompt_templates(id) ON DELETE CASCADE not valid;

alter table "public"."prompt_templates_versions" validate constraint "prompt_templates_versions_template_id_fkey";

alter table "public"."share_invitations" add constraint "fk_share_invitations_organization" FOREIGN KEY (organization_id) REFERENCES public.organizations(id) ON DELETE CASCADE not valid;

alter table "public"."share_invitations" validate constraint "fk_share_invitations_organization";

alter table "public"."share_invitations" add constraint "share_invitations_invited_user_id_fkey" FOREIGN KEY (invited_user_id) REFERENCES auth.users(id) not valid;

alter table "public"."share_invitations" validate constraint "share_invitations_invited_user_id_fkey";

alter table "public"."share_invitations" add constraint "share_invitations_inviter_user_id_fkey" FOREIGN KEY (inviter_user_id) REFERENCES auth.users(id) not valid;

alter table "public"."share_invitations" validate constraint "share_invitations_inviter_user_id_fkey";

alter table "public"."share_invitations" add constraint "valid_friend_invitation" CHECK ((((invitation_type = 'friend'::text) AND (invited_email IS NOT NULL)) OR (invitation_type = ANY (ARRAY['team'::text, 'referral'::text, 'organization'::text])))) not valid;

alter table "public"."share_invitations" validate constraint "valid_friend_invitation";

alter table "public"."stripe_subscriptions" add constraint "stripe_subscriptions_stripe_subscription_id_key" UNIQUE using index "stripe_subscriptions_stripe_subscription_id_key";

alter table "public"."stripe_subscriptions" add constraint "stripe_subscriptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."stripe_subscriptions" validate constraint "stripe_subscriptions_user_id_fkey";

alter table "public"."stripe_webhook_events" add constraint "stripe_webhook_events_stripe_event_id_key" UNIQUE using index "stripe_webhook_events_stripe_event_id_key";

alter table "public"."teams" add constraint "teams_company_id_fkey" FOREIGN KEY (company_id) REFERENCES public.companies(id) not valid;

alter table "public"."teams" validate constraint "teams_company_id_fkey";

alter table "public"."users_metadata" add constraint "users_metadata_company_id_fkey" FOREIGN KEY (company_id) REFERENCES public.companies(id) not valid;

alter table "public"."users_metadata" validate constraint "users_metadata_company_id_fkey";

alter table "public"."users_metadata" add constraint "users_metadata_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."users_metadata" validate constraint "users_metadata_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_initial_template_version()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    version_id uuid;
    template_title_en text;
    template_title_fr text;  
    author_uuid uuid;
BEGIN
    -- Get author (prefer user_id, fallback to authenticated user)
    author_uuid := COALESCE(NEW.user_id, auth.uid());
    
    -- Skip if no author identified
    IF author_uuid IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Extract titles from JSONB title field
    template_title_en := COALESCE(NEW.title->>'en', 'Untitled Template');
    template_title_fr := COALESCE(NEW.title->>'fr', template_title_en);
    
    -- Only create version if we have meaningful title content
    IF template_title_en IS NOT NULL AND template_title_en != '' THEN
        -- Insert initial version with placeholder content
        INSERT INTO public.prompt_templates_versions (
            template_id,
            version_number,
            content,
            author_id,
            is_current,
            status,
            change_notes,
            usage_count
        ) VALUES (
            NEW.id,
            '1.0', 
            jsonb_build_object('en', 'Template content will be added via version creation', 'fr', 'Le contenu du modèle sera ajouté via la création de version'),
            author_uuid,
            true,
            'draft',
            jsonb_build_object('en', 'Initial version', 'fr', 'Version initiale'),
            0
        ) RETURNING id INTO version_id;
        
        -- Update the template to reference this version (if current_version_id field exists)
        BEGIN
            UPDATE public.prompt_templates 
            SET current_version_id = version_id 
            WHERE id = NEW.id;
        EXCEPTION WHEN undefined_column THEN
            -- Ignore if current_version_id field doesn't exist yet
            NULL;
        END;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.ensure_single_current_version()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- If this version is being set as current, unset all other current versions for this template
    IF NEW.is_current = true THEN
        UPDATE public.prompt_templates_versions 
        SET is_current = false, updated_at = now()
        WHERE template_id = NEW.template_id 
        AND id != NEW.id 
        AND is_current = true;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_organization_folders(org_id uuid)
 RETURNS TABLE(id uuid, title jsonb, organization_id uuid, workspace_type text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
  BEGIN
      RETURN QUERY
      SELECT
          pf.id,
          pf.title,
          pf.organization_id,
          pf.workspace_type
      FROM prompt_folders pf
      WHERE pf.organization_id = org_id;
  END;
  $function$
;

CREATE OR REPLACE FUNCTION public.get_organization_members(org_id text)
 RETURNS TABLE(user_id uuid, email text, name text, profile_picture_url text, role text, created_at timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        um.user_id,
        au.email,
        um.name,
        um.profile_picture_url,
        (um.roles->'organizations'->org_id)::TEXT as role,
        um.created_at
    FROM users_metadata um
    INNER JOIN auth.users au ON um.user_id = au.id
    WHERE um.roles->'organizations' ? org_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_subscription(user_uuid uuid)
 RETURNS TABLE(is_active boolean, plan_id text, current_period_end timestamp with time zone, cancel_at_period_end boolean, stripe_customer_id text, stripe_subscription_id text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        CASE 
            WHEN um.subscription_status IN ('active', 'trialing') THEN true 
            ELSE false 
        END as is_active,
        um.subscription_plan as plan_id,
        um.subscription_current_period_end as current_period_end,
        COALESCE(um.subscription_cancel_at_period_end, false) as cancel_at_period_end,
        um.stripe_customer_id as stripe_customer_id,
        um.stripe_subscription_id as stripe_subscription_id
    FROM users_metadata um
    WHERE um.user_id = user_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_subscription_status(check_user_id uuid DEFAULT NULL::uuid)
 RETURNS TABLE(user_id uuid, is_active boolean, plan_id text, current_period_end timestamp with time zone, cancel_at_period_end boolean, has_stripe_customer boolean)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    target_user_id UUID;
BEGIN
    -- If no user_id provided, use the authenticated user
    IF check_user_id IS NULL THEN
        target_user_id := auth.uid();
    ELSE
        target_user_id := check_user_id;
    END IF;
    
    -- Security check: users can only access their own data
    IF (current_setting('role') != 'service_role' AND auth.uid() != target_user_id) THEN
        RAISE EXCEPTION 'Access denied: can only view your own subscription status';
    END IF;
    
    RETURN QUERY
    SELECT 
        um.user_id,
        CASE 
            WHEN um.subscription_status IN ('active', 'trialing') THEN true 
            ELSE false 
        END as is_active,
        um.subscription_plan as plan_id,
        um.subscription_current_period_end as current_period_end,
        COALESCE(um.subscription_cancel_at_period_end, false) as cancel_at_period_end,
        CASE 
            WHEN um.stripe_customer_id IS NOT NULL THEN true 
            ELSE false 
        END as has_stripe_customer
    FROM users_metadata um
    WHERE um.user_id = target_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_active_subscription(user_uuid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM users_metadata 
        WHERE user_id = user_uuid 
        AND subscription_status IN ('active', 'trialing')
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.log_subscription_changes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Only log if subscription-related fields changed
    IF (OLD.subscription_status IS DISTINCT FROM NEW.subscription_status OR
        OLD.subscription_plan IS DISTINCT FROM NEW.subscription_plan) THEN
        
        INSERT INTO subscription_audit_log (
            user_id,
            old_status,
            new_status,
            old_plan,
            new_plan,
            changed_by,
            metadata
        ) VALUES (
            NEW.user_id,
            OLD.subscription_status,
            NEW.subscription_status,
            OLD.subscription_plan,
            NEW.subscription_plan,
            CASE 
                WHEN current_setting('role') = 'service_role' THEN 'webhook'
                ELSE 'manual'
            END,
            jsonb_build_object(
                'stripe_customer_id', NEW.stripe_customer_id,
                'stripe_subscription_id', NEW.stripe_subscription_id
            )
        );
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.prevent_stripe_column_updates()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if any Stripe-related columns are being updated by non-service roles
    IF (current_setting('role') != 'service_role') THEN
        -- Prevent updates to critical Stripe columns
        IF (OLD.stripe_customer_id IS DISTINCT FROM NEW.stripe_customer_id OR
            OLD.subscription_status IS DISTINCT FROM NEW.subscription_status OR
            OLD.subscription_plan IS DISTINCT FROM NEW.subscription_plan OR
            OLD.stripe_subscription_id IS DISTINCT FROM NEW.stripe_subscription_id OR
            OLD.subscription_current_period_end IS DISTINCT FROM NEW.subscription_current_period_end OR
            OLD.subscription_cancel_at_period_end IS DISTINCT FROM NEW.subscription_cancel_at_period_end) THEN
            
            RAISE EXCEPTION 'Stripe subscription data can only be updated by the service'
                USING HINT = 'Use the Stripe customer portal or API to modify subscription data';
        END IF;
    END IF;
    
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_current_version_id()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.is_current = TRUE THEN
        -- Update the template's current_version_id to point to this version
        UPDATE prompt_templates 
        SET current_version_id = NEW.id
        WHERE id = NEW.template_id;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_favorites_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_delete_item(item_user_id uuid, item_company_id uuid, item_organization_id uuid, item_type text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Personal items (type = 'user'): only owner can delete
    IF item_type = 'user' AND item_user_id = auth.uid() THEN
        RETURN true;
    END IF;

    -- Company items (type = 'company'): admin+ can delete
    IF item_type = 'company' AND item_company_id IS NOT NULL THEN
        RETURN user_has_company_role(auth.uid(), item_company_id, 'admin');
    END IF;

    -- Organization items (type = 'organization'): admin+ can delete
    IF item_type = 'organization' AND item_organization_id IS NOT NULL THEN
        RETURN user_has_org_role(auth.uid(), item_organization_id, 'admin');
    END IF;

    RETURN false;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_read_item(item_user_id uuid, item_company_id uuid, item_organization_id uuid, item_type text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Personal items (type = 'user')
    IF item_type = 'user' AND item_user_id = auth.uid() THEN
        RETURN true;
    END IF;

    -- Company items (type = 'company')
    IF item_type = 'company' AND item_company_id IS NOT NULL THEN
        RETURN user_has_company_role(auth.uid(), item_company_id, 'viewer');
    END IF;

    -- Organization items (type = 'organization')
    IF item_type = 'organization' AND item_organization_id IS NOT NULL THEN
        RETURN user_has_org_role(auth.uid(), item_organization_id, 'viewer');
    END IF;

    RETURN false;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_can_write_item(item_user_id uuid, item_company_id uuid, item_organization_id uuid, item_type text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Personal items (type = 'user')
    IF item_type = 'user' AND item_user_id = auth.uid() THEN
        RETURN true;
    END IF;

    -- Company items (type = 'company')
    IF item_type = 'company' AND item_company_id IS NOT NULL THEN
        RETURN user_has_company_role(auth.uid(), item_company_id, 'member');
    END IF;

    -- Organization items (type = 'organization')
    IF item_type = 'organization' AND item_organization_id IS NOT NULL THEN
        RETURN user_has_org_role(auth.uid(), item_organization_id, 'member');
    END IF;

    RETURN false;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_active_subscription(check_user_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    target_user_id UUID;
BEGIN
    -- If no user_id provided, use the authenticated user
    IF check_user_id IS NULL THEN
        target_user_id := auth.uid();
    ELSE
        target_user_id := check_user_id;
    END IF;
    
    -- Security check: users can only check their own status (unless service role)
    IF (current_setting('role') != 'service_role' AND auth.uid() != target_user_id) THEN
        RAISE EXCEPTION 'Access denied: can only check your own subscription status';
    END IF;
    
    RETURN EXISTS (
        SELECT 1 FROM users_metadata 
        WHERE user_id = target_user_id 
        AND subscription_status IN ('active', 'trialing')
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_company_role(user_uuid uuid, target_company_id uuid, required_role text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if user has the required role or higher for the company
    RETURN EXISTS (
        SELECT 1 FROM users_metadata
        WHERE user_id = user_uuid
        AND company_id = target_company_id
        AND CASE required_role
            WHEN 'viewer' THEN roles->>'company' IN ('viewer', 'member', 'admin', 'owner')
            WHEN 'member' THEN roles->>'company' IN ('member', 'admin', 'owner')
            WHEN 'admin' THEN roles->>'company' IN ('admin', 'owner')
            WHEN 'owner' THEN roles->>'company' = 'owner'
            ELSE FALSE
        END
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_org_role(user_uuid uuid, target_org_id uuid, required_role text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    -- Check if user has the required role or higher for the organization
    RETURN EXISTS (
        SELECT 1 FROM users_metadata
        WHERE user_id = user_uuid
        AND target_org_id = ANY(organization_ids)
        AND CASE required_role
            WHEN 'viewer' THEN roles->'organizations'->>(target_org_id::text) IN ('viewer', 'member', 'admin', 'owner')
            WHEN 'member' THEN roles->'organizations'->>(target_org_id::text) IN ('member', 'admin', 'owner')
            WHEN 'admin' THEN roles->'organizations'->>(target_org_id::text) IN ('admin', 'owner')
            WHEN 'owner' THEN roles->'organizations'->>(target_org_id::text) = 'owner'
            ELSE FALSE
        END
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.user_subscription_expires_at(check_user_id uuid DEFAULT NULL::uuid)
 RETURNS timestamp with time zone
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    expiry_date TIMESTAMP WITH TIME ZONE;
    target_user_id UUID;
BEGIN
    -- If no user_id provided, use the authenticated user
    IF check_user_id IS NULL THEN
        target_user_id := auth.uid();
    ELSE
        target_user_id := check_user_id;
    END IF;
    
    -- Security check: users can only check their own status (unless service role)
    IF (current_setting('role') != 'service_role' AND auth.uid() != target_user_id) THEN
        RAISE EXCEPTION 'Access denied: can only check your own subscription expiry';
    END IF;
    
    SELECT subscription_current_period_end INTO expiry_date
    FROM users_metadata 
    WHERE user_id = target_user_id 
    AND subscription_status IN ('active', 'trialing');
    
    RETURN expiry_date;
END;
$function$
;

grant delete on table "public"."blog_posts" to "anon";

grant insert on table "public"."blog_posts" to "anon";

grant references on table "public"."blog_posts" to "anon";

grant select on table "public"."blog_posts" to "anon";

grant trigger on table "public"."blog_posts" to "anon";

grant truncate on table "public"."blog_posts" to "anon";

grant update on table "public"."blog_posts" to "anon";

grant delete on table "public"."blog_posts" to "authenticated";

grant insert on table "public"."blog_posts" to "authenticated";

grant references on table "public"."blog_posts" to "authenticated";

grant select on table "public"."blog_posts" to "authenticated";

grant trigger on table "public"."blog_posts" to "authenticated";

grant truncate on table "public"."blog_posts" to "authenticated";

grant update on table "public"."blog_posts" to "authenticated";

grant delete on table "public"."blog_posts" to "service_role";

grant insert on table "public"."blog_posts" to "service_role";

grant references on table "public"."blog_posts" to "service_role";

grant select on table "public"."blog_posts" to "service_role";

grant trigger on table "public"."blog_posts" to "service_role";

grant truncate on table "public"."blog_posts" to "service_role";

grant update on table "public"."blog_posts" to "service_role";

grant delete on table "public"."chats" to "anon";

grant insert on table "public"."chats" to "anon";

grant references on table "public"."chats" to "anon";

grant select on table "public"."chats" to "anon";

grant trigger on table "public"."chats" to "anon";

grant truncate on table "public"."chats" to "anon";

grant update on table "public"."chats" to "anon";

grant delete on table "public"."chats" to "authenticated";

grant insert on table "public"."chats" to "authenticated";

grant references on table "public"."chats" to "authenticated";

grant select on table "public"."chats" to "authenticated";

grant trigger on table "public"."chats" to "authenticated";

grant truncate on table "public"."chats" to "authenticated";

grant update on table "public"."chats" to "authenticated";

grant delete on table "public"."chats" to "service_role";

grant insert on table "public"."chats" to "service_role";

grant references on table "public"."chats" to "service_role";

grant select on table "public"."chats" to "service_role";

grant trigger on table "public"."chats" to "service_role";

grant truncate on table "public"."chats" to "service_role";

grant update on table "public"."chats" to "service_role";

grant delete on table "public"."companies" to "anon";

grant insert on table "public"."companies" to "anon";

grant references on table "public"."companies" to "anon";

grant select on table "public"."companies" to "anon";

grant trigger on table "public"."companies" to "anon";

grant truncate on table "public"."companies" to "anon";

grant update on table "public"."companies" to "anon";

grant delete on table "public"."companies" to "authenticated";

grant insert on table "public"."companies" to "authenticated";

grant references on table "public"."companies" to "authenticated";

grant select on table "public"."companies" to "authenticated";

grant trigger on table "public"."companies" to "authenticated";

grant truncate on table "public"."companies" to "authenticated";

grant update on table "public"."companies" to "authenticated";

grant delete on table "public"."companies" to "service_role";

grant insert on table "public"."companies" to "service_role";

grant references on table "public"."companies" to "service_role";

grant select on table "public"."companies" to "service_role";

grant trigger on table "public"."companies" to "service_role";

grant truncate on table "public"."companies" to "service_role";

grant update on table "public"."companies" to "service_role";

grant delete on table "public"."favorites" to "anon";

grant insert on table "public"."favorites" to "anon";

grant references on table "public"."favorites" to "anon";

grant select on table "public"."favorites" to "anon";

grant trigger on table "public"."favorites" to "anon";

grant truncate on table "public"."favorites" to "anon";

grant update on table "public"."favorites" to "anon";

grant delete on table "public"."favorites" to "authenticated";

grant insert on table "public"."favorites" to "authenticated";

grant references on table "public"."favorites" to "authenticated";

grant select on table "public"."favorites" to "authenticated";

grant trigger on table "public"."favorites" to "authenticated";

grant truncate on table "public"."favorites" to "authenticated";

grant update on table "public"."favorites" to "authenticated";

grant delete on table "public"."favorites" to "service_role";

grant insert on table "public"."favorites" to "service_role";

grant references on table "public"."favorites" to "service_role";

grant select on table "public"."favorites" to "service_role";

grant trigger on table "public"."favorites" to "service_role";

grant truncate on table "public"."favorites" to "service_role";

grant update on table "public"."favorites" to "service_role";

grant delete on table "public"."landing_page_blog_posts" to "anon";

grant insert on table "public"."landing_page_blog_posts" to "anon";

grant references on table "public"."landing_page_blog_posts" to "anon";

grant select on table "public"."landing_page_blog_posts" to "anon";

grant trigger on table "public"."landing_page_blog_posts" to "anon";

grant truncate on table "public"."landing_page_blog_posts" to "anon";

grant update on table "public"."landing_page_blog_posts" to "anon";

grant delete on table "public"."landing_page_blog_posts" to "authenticated";

grant insert on table "public"."landing_page_blog_posts" to "authenticated";

grant references on table "public"."landing_page_blog_posts" to "authenticated";

grant select on table "public"."landing_page_blog_posts" to "authenticated";

grant trigger on table "public"."landing_page_blog_posts" to "authenticated";

grant truncate on table "public"."landing_page_blog_posts" to "authenticated";

grant update on table "public"."landing_page_blog_posts" to "authenticated";

grant delete on table "public"."landing_page_blog_posts" to "service_role";

grant insert on table "public"."landing_page_blog_posts" to "service_role";

grant references on table "public"."landing_page_blog_posts" to "service_role";

grant select on table "public"."landing_page_blog_posts" to "service_role";

grant trigger on table "public"."landing_page_blog_posts" to "service_role";

grant truncate on table "public"."landing_page_blog_posts" to "service_role";

grant update on table "public"."landing_page_blog_posts" to "service_role";

grant delete on table "public"."landing_page_contact_form" to "anon";

grant insert on table "public"."landing_page_contact_form" to "anon";

grant references on table "public"."landing_page_contact_form" to "anon";

grant select on table "public"."landing_page_contact_form" to "anon";

grant trigger on table "public"."landing_page_contact_form" to "anon";

grant truncate on table "public"."landing_page_contact_form" to "anon";

grant update on table "public"."landing_page_contact_form" to "anon";

grant delete on table "public"."landing_page_contact_form" to "authenticated";

grant insert on table "public"."landing_page_contact_form" to "authenticated";

grant references on table "public"."landing_page_contact_form" to "authenticated";

grant select on table "public"."landing_page_contact_form" to "authenticated";

grant trigger on table "public"."landing_page_contact_form" to "authenticated";

grant truncate on table "public"."landing_page_contact_form" to "authenticated";

grant update on table "public"."landing_page_contact_form" to "authenticated";

grant delete on table "public"."landing_page_contact_form" to "service_role";

grant insert on table "public"."landing_page_contact_form" to "service_role";

grant references on table "public"."landing_page_contact_form" to "service_role";

grant select on table "public"."landing_page_contact_form" to "service_role";

grant trigger on table "public"."landing_page_contact_form" to "service_role";

grant truncate on table "public"."landing_page_contact_form" to "service_role";

grant update on table "public"."landing_page_contact_form" to "service_role";

grant delete on table "public"."messages" to "anon";

grant insert on table "public"."messages" to "anon";

grant references on table "public"."messages" to "anon";

grant select on table "public"."messages" to "anon";

grant trigger on table "public"."messages" to "anon";

grant truncate on table "public"."messages" to "anon";

grant update on table "public"."messages" to "anon";

grant delete on table "public"."messages" to "authenticated";

grant insert on table "public"."messages" to "authenticated";

grant references on table "public"."messages" to "authenticated";

grant select on table "public"."messages" to "authenticated";

grant trigger on table "public"."messages" to "authenticated";

grant truncate on table "public"."messages" to "authenticated";

grant update on table "public"."messages" to "authenticated";

grant delete on table "public"."messages" to "service_role";

grant insert on table "public"."messages" to "service_role";

grant references on table "public"."messages" to "service_role";

grant select on table "public"."messages" to "service_role";

grant trigger on table "public"."messages" to "service_role";

grant truncate on table "public"."messages" to "service_role";

grant update on table "public"."messages" to "service_role";

grant delete on table "public"."notifications" to "anon";

grant insert on table "public"."notifications" to "anon";

grant references on table "public"."notifications" to "anon";

grant select on table "public"."notifications" to "anon";

grant trigger on table "public"."notifications" to "anon";

grant truncate on table "public"."notifications" to "anon";

grant update on table "public"."notifications" to "anon";

grant delete on table "public"."notifications" to "authenticated";

grant insert on table "public"."notifications" to "authenticated";

grant references on table "public"."notifications" to "authenticated";

grant select on table "public"."notifications" to "authenticated";

grant trigger on table "public"."notifications" to "authenticated";

grant truncate on table "public"."notifications" to "authenticated";

grant update on table "public"."notifications" to "authenticated";

grant delete on table "public"."notifications" to "service_role";

grant insert on table "public"."notifications" to "service_role";

grant references on table "public"."notifications" to "service_role";

grant select on table "public"."notifications" to "service_role";

grant trigger on table "public"."notifications" to "service_role";

grant truncate on table "public"."notifications" to "service_role";

grant update on table "public"."notifications" to "service_role";

grant delete on table "public"."organizations" to "anon";

grant insert on table "public"."organizations" to "anon";

grant references on table "public"."organizations" to "anon";

grant select on table "public"."organizations" to "anon";

grant trigger on table "public"."organizations" to "anon";

grant truncate on table "public"."organizations" to "anon";

grant update on table "public"."organizations" to "anon";

grant delete on table "public"."organizations" to "authenticated";

grant insert on table "public"."organizations" to "authenticated";

grant references on table "public"."organizations" to "authenticated";

grant select on table "public"."organizations" to "authenticated";

grant trigger on table "public"."organizations" to "authenticated";

grant truncate on table "public"."organizations" to "authenticated";

grant update on table "public"."organizations" to "authenticated";

grant delete on table "public"."organizations" to "service_role";

grant insert on table "public"."organizations" to "service_role";

grant references on table "public"."organizations" to "service_role";

grant select on table "public"."organizations" to "service_role";

grant trigger on table "public"."organizations" to "service_role";

grant truncate on table "public"."organizations" to "service_role";

grant update on table "public"."organizations" to "service_role";

grant delete on table "public"."prompt_blocks" to "anon";

grant insert on table "public"."prompt_blocks" to "anon";

grant references on table "public"."prompt_blocks" to "anon";

grant select on table "public"."prompt_blocks" to "anon";

grant trigger on table "public"."prompt_blocks" to "anon";

grant truncate on table "public"."prompt_blocks" to "anon";

grant update on table "public"."prompt_blocks" to "anon";

grant delete on table "public"."prompt_blocks" to "authenticated";

grant insert on table "public"."prompt_blocks" to "authenticated";

grant references on table "public"."prompt_blocks" to "authenticated";

grant select on table "public"."prompt_blocks" to "authenticated";

grant trigger on table "public"."prompt_blocks" to "authenticated";

grant truncate on table "public"."prompt_blocks" to "authenticated";

grant update on table "public"."prompt_blocks" to "authenticated";

grant delete on table "public"."prompt_blocks" to "service_role";

grant insert on table "public"."prompt_blocks" to "service_role";

grant references on table "public"."prompt_blocks" to "service_role";

grant select on table "public"."prompt_blocks" to "service_role";

grant trigger on table "public"."prompt_blocks" to "service_role";

grant truncate on table "public"."prompt_blocks" to "service_role";

grant update on table "public"."prompt_blocks" to "service_role";

grant delete on table "public"."prompt_folders" to "anon";

grant insert on table "public"."prompt_folders" to "anon";

grant references on table "public"."prompt_folders" to "anon";

grant select on table "public"."prompt_folders" to "anon";

grant trigger on table "public"."prompt_folders" to "anon";

grant truncate on table "public"."prompt_folders" to "anon";

grant update on table "public"."prompt_folders" to "anon";

grant delete on table "public"."prompt_folders" to "authenticated";

grant insert on table "public"."prompt_folders" to "authenticated";

grant references on table "public"."prompt_folders" to "authenticated";

grant select on table "public"."prompt_folders" to "authenticated";

grant trigger on table "public"."prompt_folders" to "authenticated";

grant truncate on table "public"."prompt_folders" to "authenticated";

grant update on table "public"."prompt_folders" to "authenticated";

grant delete on table "public"."prompt_folders" to "service_role";

grant insert on table "public"."prompt_folders" to "service_role";

grant references on table "public"."prompt_folders" to "service_role";

grant select on table "public"."prompt_folders" to "service_role";

grant trigger on table "public"."prompt_folders" to "service_role";

grant truncate on table "public"."prompt_folders" to "service_role";

grant update on table "public"."prompt_folders" to "service_role";

grant delete on table "public"."prompt_templates" to "anon";

grant insert on table "public"."prompt_templates" to "anon";

grant references on table "public"."prompt_templates" to "anon";

grant select on table "public"."prompt_templates" to "anon";

grant trigger on table "public"."prompt_templates" to "anon";

grant truncate on table "public"."prompt_templates" to "anon";

grant update on table "public"."prompt_templates" to "anon";

grant delete on table "public"."prompt_templates" to "authenticated";

grant insert on table "public"."prompt_templates" to "authenticated";

grant references on table "public"."prompt_templates" to "authenticated";

grant select on table "public"."prompt_templates" to "authenticated";

grant trigger on table "public"."prompt_templates" to "authenticated";

grant truncate on table "public"."prompt_templates" to "authenticated";

grant update on table "public"."prompt_templates" to "authenticated";

grant delete on table "public"."prompt_templates" to "service_role";

grant insert on table "public"."prompt_templates" to "service_role";

grant references on table "public"."prompt_templates" to "service_role";

grant select on table "public"."prompt_templates" to "service_role";

grant trigger on table "public"."prompt_templates" to "service_role";

grant truncate on table "public"."prompt_templates" to "service_role";

grant update on table "public"."prompt_templates" to "service_role";

grant delete on table "public"."prompt_templates_comments" to "anon";

grant insert on table "public"."prompt_templates_comments" to "anon";

grant references on table "public"."prompt_templates_comments" to "anon";

grant select on table "public"."prompt_templates_comments" to "anon";

grant trigger on table "public"."prompt_templates_comments" to "anon";

grant truncate on table "public"."prompt_templates_comments" to "anon";

grant update on table "public"."prompt_templates_comments" to "anon";

grant delete on table "public"."prompt_templates_comments" to "authenticated";

grant insert on table "public"."prompt_templates_comments" to "authenticated";

grant references on table "public"."prompt_templates_comments" to "authenticated";

grant select on table "public"."prompt_templates_comments" to "authenticated";

grant trigger on table "public"."prompt_templates_comments" to "authenticated";

grant truncate on table "public"."prompt_templates_comments" to "authenticated";

grant update on table "public"."prompt_templates_comments" to "authenticated";

grant delete on table "public"."prompt_templates_comments" to "service_role";

grant insert on table "public"."prompt_templates_comments" to "service_role";

grant references on table "public"."prompt_templates_comments" to "service_role";

grant select on table "public"."prompt_templates_comments" to "service_role";

grant trigger on table "public"."prompt_templates_comments" to "service_role";

grant truncate on table "public"."prompt_templates_comments" to "service_role";

grant update on table "public"."prompt_templates_comments" to "service_role";

grant delete on table "public"."prompt_templates_versions" to "anon";

grant insert on table "public"."prompt_templates_versions" to "anon";

grant references on table "public"."prompt_templates_versions" to "anon";

grant select on table "public"."prompt_templates_versions" to "anon";

grant trigger on table "public"."prompt_templates_versions" to "anon";

grant truncate on table "public"."prompt_templates_versions" to "anon";

grant update on table "public"."prompt_templates_versions" to "anon";

grant delete on table "public"."prompt_templates_versions" to "authenticated";

grant insert on table "public"."prompt_templates_versions" to "authenticated";

grant references on table "public"."prompt_templates_versions" to "authenticated";

grant select on table "public"."prompt_templates_versions" to "authenticated";

grant trigger on table "public"."prompt_templates_versions" to "authenticated";

grant truncate on table "public"."prompt_templates_versions" to "authenticated";

grant update on table "public"."prompt_templates_versions" to "authenticated";

grant delete on table "public"."prompt_templates_versions" to "service_role";

grant insert on table "public"."prompt_templates_versions" to "service_role";

grant references on table "public"."prompt_templates_versions" to "service_role";

grant select on table "public"."prompt_templates_versions" to "service_role";

grant trigger on table "public"."prompt_templates_versions" to "service_role";

grant truncate on table "public"."prompt_templates_versions" to "service_role";

grant update on table "public"."prompt_templates_versions" to "service_role";

grant delete on table "public"."share_invitations" to "anon";

grant insert on table "public"."share_invitations" to "anon";

grant references on table "public"."share_invitations" to "anon";

grant select on table "public"."share_invitations" to "anon";

grant trigger on table "public"."share_invitations" to "anon";

grant truncate on table "public"."share_invitations" to "anon";

grant update on table "public"."share_invitations" to "anon";

grant delete on table "public"."share_invitations" to "authenticated";

grant insert on table "public"."share_invitations" to "authenticated";

grant references on table "public"."share_invitations" to "authenticated";

grant select on table "public"."share_invitations" to "authenticated";

grant trigger on table "public"."share_invitations" to "authenticated";

grant truncate on table "public"."share_invitations" to "authenticated";

grant update on table "public"."share_invitations" to "authenticated";

grant delete on table "public"."share_invitations" to "service_role";

grant insert on table "public"."share_invitations" to "service_role";

grant references on table "public"."share_invitations" to "service_role";

grant select on table "public"."share_invitations" to "service_role";

grant trigger on table "public"."share_invitations" to "service_role";

grant truncate on table "public"."share_invitations" to "service_role";

grant update on table "public"."share_invitations" to "service_role";

grant delete on table "public"."stripe_subscriptions" to "anon";

grant insert on table "public"."stripe_subscriptions" to "anon";

grant references on table "public"."stripe_subscriptions" to "anon";

grant select on table "public"."stripe_subscriptions" to "anon";

grant trigger on table "public"."stripe_subscriptions" to "anon";

grant truncate on table "public"."stripe_subscriptions" to "anon";

grant update on table "public"."stripe_subscriptions" to "anon";

grant delete on table "public"."stripe_subscriptions" to "authenticated";

grant insert on table "public"."stripe_subscriptions" to "authenticated";

grant references on table "public"."stripe_subscriptions" to "authenticated";

grant select on table "public"."stripe_subscriptions" to "authenticated";

grant trigger on table "public"."stripe_subscriptions" to "authenticated";

grant truncate on table "public"."stripe_subscriptions" to "authenticated";

grant update on table "public"."stripe_subscriptions" to "authenticated";

grant delete on table "public"."stripe_subscriptions" to "service_role";

grant insert on table "public"."stripe_subscriptions" to "service_role";

grant references on table "public"."stripe_subscriptions" to "service_role";

grant select on table "public"."stripe_subscriptions" to "service_role";

grant trigger on table "public"."stripe_subscriptions" to "service_role";

grant truncate on table "public"."stripe_subscriptions" to "service_role";

grant update on table "public"."stripe_subscriptions" to "service_role";

grant delete on table "public"."stripe_webhook_events" to "anon";

grant insert on table "public"."stripe_webhook_events" to "anon";

grant references on table "public"."stripe_webhook_events" to "anon";

grant select on table "public"."stripe_webhook_events" to "anon";

grant trigger on table "public"."stripe_webhook_events" to "anon";

grant truncate on table "public"."stripe_webhook_events" to "anon";

grant update on table "public"."stripe_webhook_events" to "anon";

grant delete on table "public"."stripe_webhook_events" to "authenticated";

grant insert on table "public"."stripe_webhook_events" to "authenticated";

grant references on table "public"."stripe_webhook_events" to "authenticated";

grant select on table "public"."stripe_webhook_events" to "authenticated";

grant trigger on table "public"."stripe_webhook_events" to "authenticated";

grant truncate on table "public"."stripe_webhook_events" to "authenticated";

grant update on table "public"."stripe_webhook_events" to "authenticated";

grant delete on table "public"."stripe_webhook_events" to "service_role";

grant insert on table "public"."stripe_webhook_events" to "service_role";

grant references on table "public"."stripe_webhook_events" to "service_role";

grant select on table "public"."stripe_webhook_events" to "service_role";

grant trigger on table "public"."stripe_webhook_events" to "service_role";

grant truncate on table "public"."stripe_webhook_events" to "service_role";

grant update on table "public"."stripe_webhook_events" to "service_role";

grant delete on table "public"."subscription_audit_log" to "anon";

grant insert on table "public"."subscription_audit_log" to "anon";

grant references on table "public"."subscription_audit_log" to "anon";

grant select on table "public"."subscription_audit_log" to "anon";

grant trigger on table "public"."subscription_audit_log" to "anon";

grant truncate on table "public"."subscription_audit_log" to "anon";

grant update on table "public"."subscription_audit_log" to "anon";

grant delete on table "public"."subscription_audit_log" to "authenticated";

grant insert on table "public"."subscription_audit_log" to "authenticated";

grant references on table "public"."subscription_audit_log" to "authenticated";

grant select on table "public"."subscription_audit_log" to "authenticated";

grant trigger on table "public"."subscription_audit_log" to "authenticated";

grant truncate on table "public"."subscription_audit_log" to "authenticated";

grant update on table "public"."subscription_audit_log" to "authenticated";

grant delete on table "public"."subscription_audit_log" to "service_role";

grant insert on table "public"."subscription_audit_log" to "service_role";

grant references on table "public"."subscription_audit_log" to "service_role";

grant select on table "public"."subscription_audit_log" to "service_role";

grant trigger on table "public"."subscription_audit_log" to "service_role";

grant truncate on table "public"."subscription_audit_log" to "service_role";

grant update on table "public"."subscription_audit_log" to "service_role";

grant delete on table "public"."teams" to "anon";

grant insert on table "public"."teams" to "anon";

grant references on table "public"."teams" to "anon";

grant select on table "public"."teams" to "anon";

grant trigger on table "public"."teams" to "anon";

grant truncate on table "public"."teams" to "anon";

grant update on table "public"."teams" to "anon";

grant delete on table "public"."teams" to "authenticated";

grant insert on table "public"."teams" to "authenticated";

grant references on table "public"."teams" to "authenticated";

grant select on table "public"."teams" to "authenticated";

grant trigger on table "public"."teams" to "authenticated";

grant truncate on table "public"."teams" to "authenticated";

grant update on table "public"."teams" to "authenticated";

grant delete on table "public"."teams" to "service_role";

grant insert on table "public"."teams" to "service_role";

grant references on table "public"."teams" to "service_role";

grant select on table "public"."teams" to "service_role";

grant trigger on table "public"."teams" to "service_role";

grant truncate on table "public"."teams" to "service_role";

grant update on table "public"."teams" to "service_role";

grant delete on table "public"."users_metadata" to "anon";

grant insert on table "public"."users_metadata" to "anon";

grant references on table "public"."users_metadata" to "anon";

grant select on table "public"."users_metadata" to "anon";

grant trigger on table "public"."users_metadata" to "anon";

grant truncate on table "public"."users_metadata" to "anon";

grant update on table "public"."users_metadata" to "anon";

grant delete on table "public"."users_metadata" to "authenticated";

grant insert on table "public"."users_metadata" to "authenticated";

grant references on table "public"."users_metadata" to "authenticated";

grant select on table "public"."users_metadata" to "authenticated";

grant trigger on table "public"."users_metadata" to "authenticated";

grant truncate on table "public"."users_metadata" to "authenticated";

grant update on table "public"."users_metadata" to "authenticated";

grant delete on table "public"."users_metadata" to "service_role";

grant insert on table "public"."users_metadata" to "service_role";

grant references on table "public"."users_metadata" to "service_role";

grant select on table "public"."users_metadata" to "service_role";

grant trigger on table "public"."users_metadata" to "service_role";

grant truncate on table "public"."users_metadata" to "service_role";

grant update on table "public"."users_metadata" to "service_role";


  create policy "Enable read access for all users"
  on "public"."blog_posts"
  as permissive
  for select
  to public
using (true);



  create policy "Enable insert for users based on user_id"
  on "public"."chats"
  as permissive
  for insert
  to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable read for users based on user_id"
  on "public"."chats"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Users can create their own favorites"
  on "public"."favorites"
  as permissive
  for insert
  to authenticated
with check ((user_id = auth.uid()));



  create policy "Users can delete their own favorites"
  on "public"."favorites"
  as permissive
  for delete
  to authenticated
using ((user_id = auth.uid()));



  create policy "Users can view their own favorites"
  on "public"."favorites"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "Enable insert access for all users"
  on "public"."landing_page_contact_form"
  as permissive
  for insert
  to public
with check (true);



  create policy "Enable insert for users based on user_id"
  on "public"."messages"
  as permissive
  for insert
  to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable read for users based on user_id"
  on "public"."messages"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable insert for service role only"
  on "public"."notifications"
  as permissive
  for insert
  to service_role
with check (true);



  create policy "Enable read for users based on user_id"
  on "public"."notifications"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable read access for all users"
  on "public"."organizations"
  as permissive
  for select
  to public
using (true);



  create policy "Organizations no delete"
  on "public"."organizations"
  as permissive
  for delete
  to authenticated
using (false);



  create policy "Organizations no insert"
  on "public"."organizations"
  as permissive
  for insert
  to authenticated
with check (false);



  create policy "Organizations read access"
  on "public"."organizations"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users_metadata um
  WHERE ((um.user_id = auth.uid()) AND (organizations.id = ANY (um.organization_ids)) AND ((um.roles -> 'organizations'::text) ? (organizations.id)::text)))));



  create policy "Organizations service role full access"
  on "public"."organizations"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Organizations update access"
  on "public"."organizations"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.users_metadata um
  WHERE ((um.user_id = auth.uid()) AND (organizations.id = ANY (um.organization_ids)) AND (((um.roles -> 'organizations'::text) ->> (organizations.id)::text) = ANY (ARRAY['admin'::text, 'owner'::text]))))))
with check ((EXISTS ( SELECT 1
   FROM public.users_metadata um
  WHERE ((um.user_id = auth.uid()) AND (organizations.id = ANY (um.organization_ids)) AND (((um.roles -> 'organizations'::text) ->> (organizations.id)::text) = ANY (ARRAY['admin'::text, 'owner'::text]))))));



  create policy "Blocks delete access"
  on "public"."prompt_blocks"
  as permissive
  for delete
  to authenticated
using (public.user_can_delete_item(user_id, company_id, organization_id, workspace_type));



  create policy "Blocks insert access"
  on "public"."prompt_blocks"
  as permissive
  for insert
  to authenticated
with check (public.user_can_write_item(user_id, company_id, organization_id, workspace_type));



  create policy "Blocks read access"
  on "public"."prompt_blocks"
  as permissive
  for select
  to authenticated
using (public.user_can_read_item(user_id, company_id, organization_id, workspace_type));



  create policy "Blocks update access"
  on "public"."prompt_blocks"
  as permissive
  for update
  to authenticated
using (public.user_can_write_item(user_id, company_id, organization_id, workspace_type))
with check (public.user_can_write_item(user_id, company_id, organization_id, workspace_type));



  create policy "Folders delete access"
  on "public"."prompt_folders"
  as permissive
  for delete
  to authenticated
using (public.user_can_delete_item(user_id, company_id, organization_id, workspace_type));



  create policy "Folders insert access"
  on "public"."prompt_folders"
  as permissive
  for insert
  to authenticated
with check (public.user_can_write_item(user_id, company_id, organization_id, workspace_type));



  create policy "Folders read access"
  on "public"."prompt_folders"
  as permissive
  for select
  to authenticated
using (public.user_can_read_item(user_id, company_id, organization_id, workspace_type));



  create policy "Folders update access"
  on "public"."prompt_folders"
  as permissive
  for update
  to authenticated
using (public.user_can_write_item(user_id, company_id, organization_id, workspace_type))
with check (public.user_can_write_item(user_id, company_id, organization_id, workspace_type));



  create policy "Service role full access folders"
  on "public"."prompt_folders"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Templates delete access"
  on "public"."prompt_templates"
  as permissive
  for delete
  to authenticated
using (public.user_can_delete_item(user_id, company_id, organization_id, workspace_type));



  create policy "Templates insert access"
  on "public"."prompt_templates"
  as permissive
  for insert
  to authenticated
with check (public.user_can_write_item(user_id, company_id, organization_id, workspace_type));



  create policy "Templates read access"
  on "public"."prompt_templates"
  as permissive
  for select
  to authenticated
using (public.user_can_read_item(user_id, company_id, organization_id, workspace_type));



  create policy "Templates update access"
  on "public"."prompt_templates"
  as permissive
  for update
  to authenticated
using (public.user_can_write_item(user_id, company_id, organization_id, workspace_type))
with check (public.user_can_write_item(user_id, company_id, organization_id, workspace_type));



  create policy "Comments delete own"
  on "public"."prompt_templates_comments"
  as permissive
  for delete
  to authenticated
using ((user_id = auth.uid()));



  create policy "Comments insert access"
  on "public"."prompt_templates_comments"
  as permissive
  for insert
  to authenticated
with check (((user_id = auth.uid()) AND (EXISTS ( SELECT 1
   FROM public.prompt_templates pt
  WHERE ((pt.id = prompt_templates_comments.template_id) AND public.user_can_read_item(pt.user_id, pt.company_id, pt.organization_id, pt.workspace_type))))));



  create policy "Comments read access"
  on "public"."prompt_templates_comments"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.prompt_templates pt
  WHERE ((pt.id = prompt_templates_comments.template_id) AND public.user_can_read_item(pt.user_id, pt.company_id, pt.organization_id, pt.workspace_type)))));



  create policy "Comments update own"
  on "public"."prompt_templates_comments"
  as permissive
  for update
  to authenticated
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Service role full access comments"
  on "public"."prompt_templates_comments"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Enable update for version authors"
  on "public"."prompt_templates_versions"
  as permissive
  for update
  to authenticated
using ((author_id = auth.uid()))
with check ((author_id = auth.uid()));



  create policy "Service role full access template versions"
  on "public"."prompt_templates_versions"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Service role full access"
  on "public"."prompt_templates_versions"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Template versions read access"
  on "public"."prompt_templates_versions"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.prompt_templates pt
  WHERE (((pt.id)::text = (prompt_templates_versions.template_id)::text) AND ((pt.user_id = auth.uid()) OR ((pt.company_id IS NOT NULL) AND public.user_has_company_role(auth.uid(), pt.company_id, 'viewer'::text)) OR ((pt.organization_id IS NOT NULL) AND public.user_has_org_role(auth.uid(), pt.organization_id, 'viewer'::text)))))));



  create policy "Template versions write access"
  on "public"."prompt_templates_versions"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.prompt_templates pt
  WHERE (((pt.id)::text = (prompt_templates_versions.template_id)::text) AND ((pt.user_id = auth.uid()) OR ((pt.company_id IS NOT NULL) AND public.user_has_company_role(auth.uid(), pt.company_id, 'member'::text)) OR ((pt.organization_id IS NOT NULL) AND public.user_has_org_role(auth.uid(), pt.organization_id, 'member'::text)))))))
with check ((EXISTS ( SELECT 1
   FROM public.prompt_templates pt
  WHERE (((pt.id)::text = (prompt_templates_versions.template_id)::text) AND ((pt.user_id = auth.uid()) OR ((pt.company_id IS NOT NULL) AND public.user_has_company_role(auth.uid(), pt.company_id, 'member'::text)) OR ((pt.organization_id IS NOT NULL) AND public.user_has_org_role(auth.uid(), pt.organization_id, 'member'::text)))))));



  create policy "Enable insert access for all users"
  on "public"."share_invitations"
  as permissive
  for insert
  to public
with check (true);



  create policy "Enable read access for all users"
  on "public"."share_invitations"
  as permissive
  for select
  to public
using (true);



  create policy "Users can create their own invitations"
  on "public"."share_invitations"
  as permissive
  for insert
  to public
with check ((auth.uid() = invited_user_id));



  create policy "Users can update their own invitations"
  on "public"."share_invitations"
  as permissive
  for update
  to public
using ((auth.uid() = invited_user_id));



  create policy "Users can view their own invitations"
  on "public"."share_invitations"
  as permissive
  for select
  to public
using ((auth.uid() = invited_user_id));



  create policy "Enable insert for authenticated users only"
  on "public"."stripe_subscriptions"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable read access for all users"
  on "public"."stripe_subscriptions"
  as permissive
  for select
  to public
using (true);



  create policy "Allow webhook insertion"
  on "public"."stripe_webhook_events"
  as permissive
  for insert
  to anon
with check (true);



  create policy "Service role full access to webhook events"
  on "public"."stripe_webhook_events"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Service role can manage audit log"
  on "public"."subscription_audit_log"
  as permissive
  for all
  to service_role
using (true)
with check (true);



  create policy "Users can view own audit log"
  on "public"."subscription_audit_log"
  as permissive
  for select
  to authenticated
using ((auth.uid() = user_id));



  create policy "Enable insert for users based on user_id"
  on "public"."users_metadata"
  as permissive
  for insert
  to authenticated
with check ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable read for users based on user_id"
  on "public"."users_metadata"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable update for users based on user_id"
  on "public"."users_metadata"
  as permissive
  for update
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


CREATE TRIGGER update_favorites_updated_at_trigger BEFORE UPDATE ON public.favorites FOR EACH ROW EXECUTE FUNCTION public.update_favorites_updated_at();

CREATE TRIGGER update_prompt_templates_updated_at BEFORE UPDATE ON public.prompt_templates FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_prompt_template_comments_updated_at BEFORE UPDATE ON public.prompt_templates_comments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER ensure_single_current_version_trigger BEFORE INSERT OR UPDATE ON public.prompt_templates_versions FOR EACH ROW EXECUTE FUNCTION public.ensure_single_current_version();

CREATE TRIGGER update_prompt_templates_versions_updated_at BEFORE UPDATE ON public.prompt_templates_versions FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER prevent_stripe_updates_trigger BEFORE UPDATE ON public.users_metadata FOR EACH ROW EXECUTE FUNCTION public.prevent_stripe_column_updates();

CREATE TRIGGER subscription_audit_trigger AFTER UPDATE ON public.users_metadata FOR EACH ROW EXECUTE FUNCTION public.log_subscription_changes();


